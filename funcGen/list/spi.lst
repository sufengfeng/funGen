C51 COMPILER V9.60.0.0   SPI                                                               09/04/2020 23:36:05 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE SPI
OBJECT MODULE PLACED IN .\list\spi.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE spi.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\list\spi
                    -.lst) TABS(2) OBJECT(.\list\spi.obj)

line level    source

   1          
   2          /*------------------------------------------------------------------*/
   3          /* --- STC MCU International Limited -------------------------------*/
   4          /* --- STC 1T Series MCU RC Demo -----------------------------------*/
   5          /* --- Mobile: (86)13922805190 -------------------------------------*/
   6          /* --- Fax: 86-0513-55012956,55012947,55012969 ---------------------*/
   7          /* --- Tel: 86-0513-55012928,55012929,55012966 ---------------------*/
   8          /* --- Web: www.GXWMCU.com -----------------------------------------*/
   9          /* --- QQ:  800003751 ----------------------------------------------*/
  10          /* If you want to use the program or the program referenced in the  */
  11          /* article, please specify in which data and procedures from STC    */
  12          /*------------------------------------------------------------------*/
  13          
  14          
  15          #include  "spi.h"
  16          unsigned char bdata dat; //dat是可位寻址的变量
  17          sbit dat7=dat^7;
  18          sbit dat6=dat^6;
  19          sbit dat5=dat^5;
  20          sbit dat4=dat^4;
  21          sbit dat3=dat^3;
  22          sbit dat2=dat^2;
  23          sbit dat1=dat^1;
  24          sbit dat0=dat^0;            // 取出dat的各个位
  25          /******************************************************************
  26          - 功能描述：IO模拟SPI，发送一个字节
  27          - 参数说明：x:要发送的字节
  28          - 注：很多情况下，SPI是需要有较高的速度的，此函数中不使用任何循环
  29                 结构，如for(;;) while等等，并且使用了位寻址就是为了提高速度
  30          ******************************************************************/
  31          void SPI_WriteByte(unsigned char x)
  32          {
  33   1      /*----这种使用循环与位运算的实现方式，速度要比直接用位寻址与顺序执行方式实现慢得多
  34   1      ----因为它把大部分的时间花在了循环因子的递增、比较与位运行上了
  35   1          unDIOgnedchar i=0;
  36   1          for(i=0;i<8;i++)
  37   1          {
  38   1              SPI_DIO=x&(0x80>>i);
  39   1              SPI_CLK=0;
  40   1              SPI_CLK=1;
  41   1          }
  42   1      ----------------------------------*/  
  43   1          dat=x;        // 将x的值赋给可位寻址的变量dat，以便取出各个位
  44   1              
  45   1          SPI_DIO=dat7;   // 取出第7个位，写到数据线上   （高位在前）
  46   1          SPI_CLK=0;
  47   1          SPI_CLK=1;     // 时钟线产生上升沿，数据被写入
  48   1         
  49   1          SPI_DIO=dat6;
  50   1          SPI_CLK=0;
  51   1          SPI_CLK=1;
  52   1         
  53   1          SPI_DIO=dat5;
  54   1          SPI_CLK=0;
C51 COMPILER V9.60.0.0   SPI                                                               09/04/2020 23:36:05 PAGE 2   

  55   1          SPI_CLK=1;
  56   1         
  57   1          SPI_DIO=dat4;
  58   1          SPI_CLK=0;
  59   1          SPI_CLK=1;
  60   1         
  61   1          SPI_DIO=dat3;
  62   1          SPI_CLK=0;
  63   1          SPI_CLK=1;
  64   1         
  65   1          SPI_DIO=dat2;
  66   1          SPI_CLK=0;
  67   1          SPI_CLK=1;
  68   1         
  69   1          SPI_DIO=dat1;
  70   1          SPI_CLK=0;
  71   1          SPI_CLK=1;
  72   1         
  73   1          SPI_DIO=dat0;
  74   1          SPI_CLK=0;
  75   1          SPI_CLK=1;
  76   1      }
  77             
  78          /******************************************************************
  79          - 功能描述：IO模拟SPI，读取一个字节
  80          - 返回说明：读到的字节
  81          - 注：很多情况下，SPI是需要有较高的速度的，此函数中不使用任何循环
  82             结构，如for(;;) while等等，并且使用了位寻址就是为了提高速度
  83          ******************************************************************/
  84          unsigned char SPI_ReadByte()
  85          {  
  86   1          /*----这种使用循环与位运算的实现方式，速度要比直接用位寻址与顺序执行方式实现慢得多
  87   1          ----因为它把大部分的时间花在了循环因子的递增、比较与位运行上了
  88   1          unDIOgnedchar i=0,temp=0;
  89   1          SPI_DIO=1;
  90   1          for(i=0;i<8;i++)
  91   1          {
  92   1              SPI_CLK=1;
  93   1              SPI_CLK=0;
  94   1              if(SPI_DIO)temp|=0x80>>i;
  95   1          }
  96   1          returntemp;
  97   1          ----------------------------------*/
  98   1          SPI_DO=1;
  99   1         
 100   1          SPI_CLK=1;
 101   1          SPI_CLK=0;        // 时钟线产生下降沿，芯片输出数据（高位在前）
 102   1          dat7=SPI_DO;
 103   1         
 104   1          SPI_CLK=1;
 105   1          SPI_CLK=0;
 106   1          dat6=SPI_DO;
 107   1         
 108   1          SPI_CLK=1;
 109   1          SPI_CLK=0;
 110   1          dat5=SPI_DO;
 111   1         
 112   1          SPI_CLK=1;
 113   1          SPI_CLK=0;
 114   1          dat4=SPI_DO;
 115   1         
 116   1          SPI_CLK=1;
C51 COMPILER V9.60.0.0   SPI                                                               09/04/2020 23:36:05 PAGE 3   

 117   1          SPI_CLK=0;
 118   1          dat3=SPI_DO;
 119   1         
 120   1          SPI_CLK=1;
 121   1          SPI_CLK=0;
 122   1          dat2=SPI_DO;
 123   1         
 124   1          SPI_CLK=1;
 125   1          SPI_CLK=0;
 126   1          dat1=SPI_DO;
 127   1         
 128   1          SPI_CLK=1;
 129   1          SPI_CLK=0;
 130   1          dat0=SPI_DO;
 131   1         
 132   1          return(dat);
 133   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    136    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      1    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

C51 COMPILER V9.60.0.0   SPI_FLASH                                                         09/04/2020 23:36:05 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE SPI_FLASH
OBJECT MODULE PLACED IN .\list\spi_flash.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE spi_flash.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\li
                    -st\spi_flash.lst) TABS(2) OBJECT(.\list\spi_flash.obj)

line level    source

   1          #include "spi.h"
   2          #include "spi_flash.h"
   3          //*************** 写允许（将WEL置位） **************************** OK
   4          void WriteEnable  (void)
   5          {
   6   1          CS=0;
   7   1          SPI_WriteByte(W25X_WriteEnable);  
   8   1          CS=1;
   9   1      }
  10          //*************** 写禁止（将WEL清0） ****************************  OK
  11          void WriteDisable (void)
  12          {
  13   1          CS=0;
  14   1          SPI_WriteByte(W25X_WriteDisable);  
  15   1          CS=1;
  16   1      }
  17          // 功能：读取W25Q16芯片的状态。
  18          // 返回值：状态寄存器数据字节
  19          // 注：W25X16内部状态寄存器第0位=0表示空闲，0位=1表示忙。
  20          unsigned  char W25Q16_ReadStatus()
  21          {
  22   1          unsigned char status=0;
  23   1          CS=0;
  24   1          SPI_WriteByte(W25X_ReadStatus);   // 0x05读取状态的命令字
  25   1          status=SPI_ReadByte();        // 读取状态字节
  26   1          CS=1;                         // 关闭片选
  27   1          return status;
  28   1      }  
  29          // 功能：写W25Q16芯片的状态寄存器。
  30          // 只有SPR、TB、BP2、BP1、BP0 (bit7、5、4、3、2)可以写、
  31          // 注：W25X16内部状态寄存器第0位=0表示空闲，0位=1表示忙。
  32          void W25Q16_WriteStatus(unsigned  char Status)
  33          {
  34   1          CS=0;
  35   1          SPI_WriteByte(W25X_WriteStatus);  // 0x01读取状态的命令字
  36   1          SPI_WriteByte(Status);            // 写入一个字节
  37   1          CS=1;                         // 关闭片选
  38   1      }
  39          //SPI在一页(0~65535)内写入少于256个字节的数据
  40          //在指定地址开始写入最大256字节的数据
  41          //pbuf:数据存储区
  42          //WriteAddr:开始写入的地址(24bit)
  43          //Len:要写入的字节数(最大256),该数不应该超过该页的剩余字节数!!!  
  44          void W25X_Flash_Write_Page(u8* pbuf,u32  WriteAddr,u16 Len)
  45          {
  46   1          u16 i;
  47   1          while(W25Q16_ReadStatus()&0x01);    //判断是否忙
  48   1         WriteEnable();                  //SET WEL
  49   1          CS=0;                            //使能器件   
  50   1         SPI_WriteByte(W25X_Writepage);      //发送写页命令
  51   1         SPI_WriteByte((u8)((WriteAddr)>>16)); //发送24bit地址   
  52   1         SPI_WriteByte((u8)((WriteAddr)>>8));   
  53   1         SPI_WriteByte((u8)WriteAddr);  
  54   1          for(i=0;i<Len;i++)               //循环写数
C51 COMPILER V9.60.0.0   SPI_FLASH                                                         09/04/2020 23:36:05 PAGE 2   

  55   1          {
  56   2              SPI_WriteByte(*pbuf++);      
  57   2          }
  58   1          CS=1;                              //取消片选
  59   1          while(W25Q16_ReadStatus()&0x01);   //等待写入结束   
  60   1      }
  61          //无检验写SPI FLASH
  62          //必须确保所写的地址范围内的数据全部为0XFF,否则在非0XFF处写入的数据将失败!
  63          //具有自动换页功能
  64          //在指定地址开始写入指定长度的数据
  65          //pbuf:数据存储区
  66          //WriteAddr:开始写入的地址(24bit)
  67          //Len:要写入的字节数(最大65535)
  68          void SPI_Flash_Write_NoCheck(u8 * pbuf,u32  WriteAddr,u16 Len)
  69          {
  70   1          u16 PageLen;                  // 页内写入字节长度
  71   1          PageLen=256-WriteAddr%256;    // 单页剩余的字节数 （单页剩余空间）
  72   1          if(Len<=PageLen) PageLen=Len; // 不大于256 个字节
  73   1          while(1)
  74   1          {
  75   2              W25X_Flash_Write_Page(pbuf,WriteAddr,PageLen);
  76   2              if(PageLen==Len)break;   // 写入结束了
  77   2              else
  78   2              {
  79   3                  pbuf+=PageLen;
  80   3                  WriteAddr+=PageLen;
  81   3                  Len-=PageLen;              //  减去已经写入了的字节数
  82   3                  if(Len>256)PageLen=256;   // 一次可以写入256 个字节
  83   3                  else PageLen=Len;          // 不够256 个字节了
  84   3              }
  85   2          }
  86   1      }
  87          //读取SPI FLASH  
  88          //在指定地址开始读取指定长度的数据
  89          //pbuf:数据存储区
  90          //ReadAddr:开始读取的地址(24bit)
  91          //Len:要读取的字节数(最大65535)
  92          void SPI_Flash_Read(u8 * pbuf,u32 ReadAddr,u16 Len)   
  93          {
  94   1          u16 i;  
  95   1          while(W25Q16_ReadStatus()&0x01);      // 判断是否忙                                                   
             -  
  96   1          CS=0;                                 // 使能器件   
  97   1          SPI_WriteByte(W25X_ReadDATA8);        // 发送读取命令   
  98   1          SPI_WriteByte((u8)((ReadAddr)>>16));  // 发送24bit地址   
  99   1         SPI_WriteByte((u8)((ReadAddr)>>8));   
 100   1         SPI_WriteByte((u8)ReadAddr);  
 101   1         for(i=0;i<Len;i++)
 102   1          {
 103   2             *pbuf++=SPI_ReadByte();            // 读一个字节   
 104   2          }
 105   1          CS=1;                                  // 取消片选            
 106   1      }  
 107          //*************** 4K扇擦除************************OK
 108          //擦除一个扇区
 109          //Dst_Addr:扇区地址 0~511 for w25x16
 110          //擦除一个扇区的最少时间:150ms
 111          void W25X_SectorErase(unsigned  long Addr24) //擦除资料图示的4KB空间
 112          {
 113   1          unsigned char Addr1;       // 最低地址字节
 114   1          unsigned char Addr2;       // 中间地址字节
 115   1          unsigned char Addr3;       // 最高地址字节  
C51 COMPILER V9.60.0.0   SPI_FLASH                                                         09/04/2020 23:36:05 PAGE 3   

 116   1          Addr1=Addr24;
 117   1          Addr24=Addr24>>8;
 118   1          Addr2=Addr24;
 119   1          Addr24=Addr24>>8;
 120   1          Addr3=Addr24;                      // 把地址拆开来  
 121   1          while(W25Q16_ReadStatus()&0x01);   // 判断是否忙   
 122   1          WriteEnable();                     // 写允许
 123   1          CS=0;
 124   1          SPI_WriteByte(W25X_S_Erase);       // 整扇擦除命令
 125   1          SPI_WriteByte(Addr3);
 126   1          SPI_WriteByte(Addr2);
 127   1          SPI_WriteByte(Addr1);
 128   1          CS=1;
 129   1          while(W25Q16_ReadStatus()&0x01);   // 等待擦除完成
 130   1      }
 131          //*************** 块擦除/64K页************************* OK
 132          void W25X_BlockErase(unsigned  long Addr24)  //擦除资料图示的64KB空间
 133          {
 134   1          unsigned char Addr1;       // 最低地址字节
 135   1          unsigned char Addr2;       // 中间地址字节
 136   1          unsigned char Addr3;       // 最高地址字节  
 137   1          Addr1=Addr24;
 138   1          Addr24=Addr24>>8;
 139   1          Addr2=Addr24;
 140   1          Addr24=Addr24>>8;
 141   1          Addr3=Addr24;                      // 把地址拆开来  
 142   1          while(W25Q16_ReadStatus()&0x01);   // 判断是否忙   
 143   1          WriteEnable();                     // 写允许
 144   1          CS=0;
 145   1          SPI_WriteByte(W25X_B_Erase);       // 整扇擦除命令
 146   1          SPI_WriteByte(Addr3);
 147   1          SPI_WriteByte(Addr2);
 148   1          SPI_WriteByte(Addr1);
 149   1          CS=1;
 150   1          while(W25Q16_ReadStatus()&0x01);   // 等待擦除完成
 151   1      }
 152          //**************片擦除  ****************** OK
 153          // W25X16：25S     W25X32：40S   W25X64：40S
 154          void W25X_ChipErase(void)
 155          {
 156   1          while(W25Q16_ReadStatus()&0x01);   // 判断是否忙   
 157   1          WriteEnable();                     // 写允许
 158   1          CS=0;
 159   1          SPI_WriteByte(W25X_C_Erase);       // 整片擦除命令
 160   1          CS=1;                              // 从CS=1时开始执行擦除
 161   1          while(W25Q16_ReadStatus()&0x01);   // 等待擦除完成   
 162   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    910    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----      48
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

C51 COMPILER V9.60.0.0   MAIN                                                              09/04/2020 23:56:43 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\list\main.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE main.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\list\ma
                    -in.lst) TABS(2) OBJECT(.\list\main.obj)

line level    source

   1          
   2          /*------------------------------------------------------------------*/
   3          /* --- STC MCU International Limited -------------------------------*/
   4          /* --- STC 1T Series MCU RC Demo -----------------------------------*/
   5          /* --- Mobile: (86)13922805190 -------------------------------------*/
   6          /* --- Fax: 86-0513-55012956,55012947,55012969 ---------------------*/
   7          /* --- Tel: 86-0513-55012928,55012929,55012966 ---------------------*/
   8          /* --- Web: www.GXWMCU.com -----------------------------------------*/
   9          /* --- QQ:  800003751 ----------------------------------------------*/
  10          /* If you want to use the program or the program referenced in the  */
  11          /* article, please specify in which data and procedures from STC    */
  12          /*------------------------------------------------------------------*/
  13          
  14          #include  "delay.h"
  15          #include  "config.h"
  16          #include  "USART1.h"
  17          #include  "USART2.h"
  18          #include  "timer.h"
  19          #include  "GPIO.h"
  20          #include "spi.h"
  21          #include "spi_flash.h"
  22          
  23          
  24          
  25          /*************  功能说明  **************
  26          
  27          双串口全双工中断方式收发通讯程序。
  28          
  29          通过PC向MCU发送数据, MCU收到后通过串口把收到的数据原样返回.
  30          
  31          ******************************************/
  32          
  33          /*************  本地常量声明  **************/
  34          
  35          
  36          /*************  本地变量声明  **************/
  37          
  38          
  39          /*************  本地函数声明  **************/
  40          
  41          
  42          
  43          /*************  外部函数和变量声明 *****************/
  44          
  45          /*************  串口1初始化函数 *****************/
  46          void  UART1_config(void)
  47          {
  48   1        COMx_InitDefine   COMx_InitStructure;         //结构定义
  49   1        COMx_InitStructure.UART_Mode      = UART_8bit_BRTx;   //模式,       UART_ShiftRight,UART_8bit_BRTx,UART_9b
             -it,UART_9bit_BRTx
  50   1        COMx_InitStructure.UART_BRT_Use   = BRT_Timer1;     //使用波特率,   BRT_Timer1, BRT_Timer2 (注意: 串口2固定
             -使用BRT_Timer2)
  51   1        COMx_InitStructure.UART_BaudRate  = 115200ul;     //波特率, 一般 110 ~ 115200
  52   1        COMx_InitStructure.UART_RxEnable  = ENABLE;       //接收允许,   ENABLE或DISABLE
C51 COMPILER V9.60.0.0   MAIN                                                              09/04/2020 23:56:43 PAGE 2   

  53   1        COMx_InitStructure.BaudRateDouble = DISABLE;      //波特率加倍, ENABLE或DISABLE
  54   1        COMx_InitStructure.UART_Interrupt = ENABLE;       //中断允许,   ENABLE或DISABLE
  55   1        COMx_InitStructure.UART_Polity    = PolityLow;      //中断优先级, PolityLow,PolityHigh
  56   1        COMx_InitStructure.UART_P_SW      = UART1_SW_P30_P31; //切换端口,   UART1_SW_P30_P31,UART1_SW_P36_P37,UAR
             -T1_SW_P16_P17(必须使用内部时钟)
  57   1        COMx_InitStructure.UART_RXD_TXD_Short = DISABLE;    //内部短路RXD与TXD, 做中继, ENABLE,DISABLE
  58   1        USART_Configuration(USART1, &COMx_InitStructure);   //初始化串口1 USART1,USART2
  59   1      
  60   1        PrintString1("STC15F2K60S2 UART1 Test Prgramme!\r\n");  //SUART1发送一个字符串
  61   1      }
  62          
  63          
  64          void  UART2_config(void)
  65          {
  66   1        COMx_InitDefine   COMx_InitStructure;         //结构定义
  67   1        COMx_InitStructure.UART_Mode      = UART_8bit_BRTx;   //模式,       UART_ShiftRight,UART_8bit_BRTx,UART_9b
             -it,UART_9bit_BRTx
  68   1        COMx_InitStructure.UART_BaudRate  = 115200ul;     //波特率,     110 ~ 115200
  69   1        COMx_InitStructure.UART_RxEnable  = ENABLE;       //接收允许,   ENABLE或DISABLE
  70   1        COMx_InitStructure.UART_Interrupt = ENABLE;       //中断允许,   ENABLE或DISABLE
  71   1        COMx_InitStructure.UART_Polity    = PolityLow;      //中断优先级, PolityLow,PolityHigh
  72   1        COMx_InitStructure.UART_P_SW      = UART2_SW_P10_P11; //切换端口,   UART2_SW_P10_P11,UART2_SW_P46_P47
  73   1        USART_Configuration(USART2, &COMx_InitStructure);   //初始化串口2 USART1,USART2
  74   1        PrintString2("STC15F2K60S2 UART2 Test Prgramme!\r\n");  //SUART2发送一个字符串
  75   1      }
  76          
  77          
  78          /************************ IO口配置 ****************************/
  79          void  GPIO_config(void)
  80          {
  81   1        GPIO_InitTypeDef  GPIO_InitStructure;       //结构定义
  82   1        GPIO_InitStructure.Pin  = GPIO_Pin_2 | GPIO_Pin_3;  //指定要初始化的IO, GPIO_Pin_0 ~ GPIO_Pin_7, 或操作
  83   1        GPIO_InitStructure.Mode = GPIO_OUT_PP;        //指定IO的输入或输出方式,GPIO_PullUp,GPIO_HighZ,GPIO_OUT_OD,GPI
             -O_OUT_PP
  84   1        GPIO_Inilize(GPIO_P3,&GPIO_InitStructure);      //初始化
  85   1        
  86   1      }
  87          
  88          /************************ 定时器配置 ****************************/
  89          void  Timer_config(void)
  90          {
  91   1        TIM_InitTypeDef   TIM_InitStructure;          //结构定义
  92   1        TIM_InitStructure.TIM_Mode      = TIM_16BitAutoReload;  //指定工作模式,   TIM_16BitAutoReload,TIM_16Bit,TI
             -M_8BitAutoReload,TIM_16BitAutoReloadNoMask
  93   1        TIM_InitStructure.TIM_Polity    = PolityLow;      //指定中断优先级, PolityHigh,PolityLow
  94   1        TIM_InitStructure.TIM_Interrupt = ENABLE;       //中断是否允许,   ENABLE或DISABLE
  95   1        TIM_InitStructure.TIM_ClkSource = TIM_CLOCK_1T;     //指定时钟源,     TIM_CLOCK_1T,TIM_CLOCK_12T,TIM_CLOCK_
             -Ext
  96   1        TIM_InitStructure.TIM_ClkOut    = ENABLE;       //是否输出高速脉冲, ENABLE或DISABLE
  97   1        TIM_InitStructure.TIM_Value     = 65536UL - (MAIN_Fosc / 100000UL);   //初值,
  98   1        TIM_InitStructure.TIM_Run       = ENABLE;       //是否初始化后启动定时器, ENABLE或DISABLE
  99   1        Timer_Inilize(Timer0,&TIM_InitStructure);       //初始化Timer0    Timer0,Timer1,Timer2
 100   1      
 101   1      //  TIM_InitStructure.TIM_Mode      = TIM_16BitAutoReload;  //指定工作模式,   TIM_16BitAutoReload,TIM_16Bit,
             -TIM_8BitAutoReload,TIM_16BitAutoReloadNoMask
 102   1      //  TIM_InitStructure.TIM_Polity    = PolityLow;      //指定中断优先级, PolityHigh,PolityLow
 103   1      //  TIM_InitStructure.TIM_Interrupt = ENABLE;       //中断是否允许,   ENABLE或DISABLE
 104   1      //  TIM_InitStructure.TIM_ClkSource = TIM_CLOCK_1T;     //指定时钟源, TIM_CLOCK_1T,TIM_CLOCK_12T,TIM_CLOCK_Ex
             -t
 105   1      //  TIM_InitStructure.TIM_ClkOut    = ENABLE;       //是否输出高速脉冲, ENABLE或DISABLE
 106   1      //  TIM_InitStructure.TIM_Value     = 65536UL - (MAIN_Fosc / 1000);   //初值,
 107   1      //  TIM_InitStructure.TIM_Run       = ENABLE;       //是否初始化后启动定时器, ENABLE或DISABLE
C51 COMPILER V9.60.0.0   MAIN                                                              09/04/2020 23:56:43 PAGE 3   

 108   1      //  Timer_Inilize(Timer1,&TIM_InitStructure);       //初始化Timer1    Timer0,Timer1,Timer2
 109   1      
 110   1      //  TIM_InitStructure.TIM_Interrupt = ENABLE;       //中断是否允许,   ENABLE或DISABLE. (注意: Timer2固定为16位
             -自动重装, 中断固定为低优先级)
 111   1      //  TIM_InitStructure.TIM_ClkSource = TIM_CLOCK_12T;    //指定时钟源,     TIM_CLOCK_1T,TIM_CLOCK_12T,TIM_CLOC
             -K_Ext
 112   1      //  TIM_InitStructure.TIM_ClkOut    = ENABLE;       //是否输出高速脉冲, ENABLE或DISABLE
 113   1      //  TIM_InitStructure.TIM_Value     = 65536UL - (MAIN_Fosc / (50*12));    //初值
 114   1      //  TIM_InitStructure.TIM_Run       = ENABLE;       //是否初始化后启动定时器, ENABLE或DISABLE
 115   1      //  Timer_Inilize(Timer2,&TIM_InitStructure);       //初始化Timer2    Timer0,Timer1,Timer2
 116   1      }
 117          
 118          void  SPI_config(void)
 119          {
 120   1      
 121   1      }
 122          
 123          
 124          
 125          /**********************************************/
 126          void main(void)
 127          {
 128   1        u8  i;
 129   1      //  unsigned char    Send_DATA[500];  // 要发送的数据
 130   1      //  unsigned char    Rec_DATA[500];   // 已接收的数据
 131   1      //  for(i=0;i<500;i++)
 132   1      //    {
 133   1      //      Send_DATA=i;
 134   1      //      Rec_DATA=0;
 135   1      //    } 
 136   1        UART2_config();
 137   1        
 138   1        GPIO_config();
 139   1        Timer_config();
 140   1        SPI_config();
 141   1        UART1_config();//保证调试串口好用
 142   1        
 143   1        EA = 1;
 144   1        
 145   1        
 146   1      //  delay_ms(500);                     // 等待W25Q16初始化完毕
 147   1      //  
 148   1      //  W25X_SectorErase(0x000000);          //4K擦除
 149   1      //  //**************************   
 150   1      //  SPI_Flash_Write_NoCheck(Send_DATA,0x000000,500);    //写N个数
 151   1      //  SPI_Flash_Read(Rec_DATA,0x000000,500);   //读N个数
 152   1      
 153   1        while (1)
 154   1        {
 155   2          delay_ms(10);
 156   2          PrintString2("running");
 157   2          
 158   2          if(COM1.RX_TimeOut > 0)   //超时计数
 159   2          {
 160   3            if(--COM1.RX_TimeOut == 0)
 161   3            {
 162   4              if(COM1.RX_Cnt > 0)
 163   4              {
 164   5                for(i=0; i<COM1.RX_Cnt; i++)  TX1_write2buff(RX1_Buffer[i]);  //收到的数据原样返回
 165   5              }
 166   4              COM1.RX_Cnt = 0;
 167   4            }
C51 COMPILER V9.60.0.0   MAIN                                                              09/04/2020 23:56:43 PAGE 4   

 168   3          }
 169   2          
 170   2          if(COM2.RX_TimeOut > 0)   //超时计数
 171   2          {
 172   3            if(--COM2.RX_TimeOut == 0)
 173   3            {
 174   4              if(COM2.RX_Cnt > 0)
 175   4              {
 176   5                for(i=0; i<COM2.RX_Cnt; i++)  
 177   5                  TX2_write2buff(RX2_Buffer[i]);  //收到的数据原样返回
 178   5              }
 179   4              COM2.RX_Cnt = 0;
 180   4            }
 181   3          }
 182   2      //    if(COM1.RX_TimeOut > 0)
 183   2      //    {
 184   2      //      if(--COM1.RX_TimeOut == 0)
 185   2      //      {
 186   2      //        if(COM1.RX_Cnt > 0)
 187   2      //        {
 188   2      //          
 189   2      //          COM1.RX_Cnt++;  //多发一个无效的字节
 190   2      //          for(i=0; i<COM1.RX_Cnt; i++)  
 191   2      //            ;
 192   2      //            //SPI_WriteToTxBuf(RX1_Buffer[i]);  //串口收到的数据转发SPI
 193   2      //          
 194   2      //        }
 195   2      //        COM1.RX_Cnt = 0;  COM1.B_RX_OK = 0;
 196   2      //      }
 197   2      //    }
 198   2      //    TX1_write2buff('a');
 199   2        
 200   2        }
 201   1      }
 202          
 203          
 204          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    353    ----
   CONSTANT SIZE    =     80    ----
   XDATA SIZE       =   ----      37
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
